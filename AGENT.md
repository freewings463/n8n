# 架构迁移（DDD 预重构）工作约定

本文件用于在**重构前**进行源文件迁移（目录/分层/限界上下文）时的统一规则与**交付物文档格式**约定。

目标：先建立**正确、可验证**的结构基础，为后续 AI/人工重构提供上下文信息；迁移阶段不追求一次性完美，优先保证可回退与可验证。

---

## 1) 核心迁移规则（必须遵守）

### 1. 职责优先，文件名为次
- 不要根据文件名判断归属，必须基于代码的**实际职责**决定迁移位置。
- 每个源文件在迁移前必须完成“职责分析文档化”，至少回答：
  - 该文件解决什么业务问题
  - 涉及哪些实体/值对象（或核心概念）
  - 有哪些外部依赖（DB、HTTP、SDK、框架、IO 等）
  - 目标归属 DDD 分层：领域层 / 应用层 / 接口层 / 基础设施层

### 2. 边界保持，逐步迁移
- 迁移过程必须保持原代码完整性，避免在迁移过程中修改业务逻辑。
- 第一次迁移只做“剪切-粘贴/移动”，不做重构、不做抽象、不做风格清理。
- 移动文件必须使用 `git mv`（保留历史）。
- 每个被迁移文件必须添加迁移标记注释（语言使用对应注释语法）：
  - `TODO-REFACTOR-DDD: [原路径] -> [目标DDD上下文/分层]`

### 3. 依赖图先行，避免循环
- 先构建依赖关系图，再确定移动顺序与批次。
- 迁移顺序必须从**叶子节点（依赖最少）**开始，逐步向上。
- 按 DDD 依赖方向收敛：`领域层 <- 应用层 <- 接口层 <- 基础设施层`（即上层可以依赖下层的抽象/契约，但避免反向依赖与环）。

### 4. 上下文映射清晰
- 必须明确“原模块/包”与“目标限界上下文”的对应关系，并记录置信度。
- 必须维护映射矩阵（见“交付物格式”）。

### 5. 测试保护，迁移验证
- 每次移动后必须保证：能编译/能启动（适用时）且基础测试通过（至少 smoke）。
- 鼓励为迁移建立专用验证脚本/测试套件（按批次执行）。
- 必要时保留原路径作为“转发器/兼容层”（逐步替换），避免一次性大爆炸变更。

### 6. 分层原则严格
- **领域层（Domain）**：只包含实体、值对象、领域服务、领域事件、领域规则/策略、仓储接口（契约）。
- **应用层（Application）**：只包含用例/工作流协调、事务边界、应用服务、端口（输入/输出）。
- **接口层（Interface/Adapters）**：只包含控制器/路由、DTO/请求响应模型、权限与输入校验、适配器（面向外部协议）。
- **基础设施层（Infrastructure）**：只包含技术实现（DB、消息、外部 API、缓存、第三方 SDK、文件系统、框架集成）。
- 迁移时必须抵制“为了方便”而违规混放职责。

### 7. 文档驱动，AI 可读
- 每个迁移文件必须包含可机器读取的元信息（建议置顶），用于后续 AI 辅助重构与追踪。
- 元信息至少包含：原始职责、目标上下文、目标分层、关联实体、外部依赖、待重构点。

### 8. 增量验证策略
- 每批迁移完成后必须验证架构约束（例如：禁止领域层依赖基础设施层）。
- 有条件时引入架构测试工具（如 ArchUnit/NetArchTest 等）或自定义约束检查脚本。

### 9. 保留逃生通道
- 每个迁移批次必须有明确回退策略：
  - 批次独立提交/分支（或至少可逆的提交序列）
  - 保持原结构镜像备份（或可一键回滚）
  - 设计兼容层处理跨上下文调用，避免硬断裂

### 10. 性能基线监控
- 迁移不应引入性能退化；迁移前后应可对比关键路径指标。
- 有条件时建立性能基准测试，并在每批迁移后运行并记录结果。

---

## 2) 推荐工具（按语言/场景选用）

- 依赖分析：`jdeps`（Java）、`Depends`（C#）、`madge`（JS/TS）
- 架构验证：ArchUnit、NetArchTest（或自定义依赖约束脚本）
- 代码可视化：SourceTrail、CodeMap
- 批量重构：IntelliJ Structural Search、Roslynator

---

## 3) 执行顺序（建议）

1. 分析阶段（约 20%）
   - 绘制原始依赖图
   - 识别 DDD 限界上下文边界
   - 创建映射矩阵
2. 规划阶段（约 15%）
   - 确定迁移批次（叶子 -> 根）
   - 设计验证策略（编译/测试/架构约束/性能基线）
   - 准备工具链与脚本
3. 执行阶段（约 40%）
   - 按批次迁移（优先叶子节点）
   - 每次迁移后立即验证
   - 记录问题与决策
4. 验证阶段（约 25%）
   - 架构约束检查
   - 功能回归测试
   - 性能基准测试

---

## 4) 交付物：迁移文档格式（必须遵守）

### 4.1 目录与命名约定
- 迁移文档统一放在：`docs/migration/`
- 批次文档：`docs/migration/batches/<batch_id>.md`
  - `batch_id` 推荐：`YYYY-MM-DD-<short_name>`（例：`2026-01-18-auth-context`）
- 映射矩阵（单一真源）：`docs/migration/mapping-matrix.md`
- 依赖图产物（可选）：`docs/migration/dependency-graphs/`（图片/文本/工具导出文件）

### 4.2 单文件“迁移元信息”注释格式（置顶）
> 用于代码内追踪与 AI 可读；注释语法请按语言替换（JS/TS/Java 用 `/** */`，Python 用 `"""` 或 `#`，Go 用 `//` 等）。

模板（字段允许补充，但不得删除）：
```
MIGRATION-META:
  source_path: <原路径>
  target_context: <目标限界上下文>
  target_layer: <Domain|Application|Interface|Infrastructure>
  responsibility: <一句话描述职责>
  entities: [<EntityOrConcept1>, <EntityOrConcept2>]
  external_dependencies: [<db/http/sdk/framework/...>]
  mapping_confidence: <High|Medium|Low>
  todo_refactor_ddd:
    - <待重构点 1>
    - <待重构点 2>
  moved_in_batch: <batch_id>
```
并额外保留一行便于检索的标记：
- `TODO-REFACTOR-DDD: [原路径] -> [目标DDD上下文/分层]`

### 4.3 映射矩阵文档格式（`mapping-matrix.md`）
必须包含一张表（可追加列，但不得删改基础列）：

| 原模块/包名 | 核心职责 | 对应DDD上下文 | 对应分层 | 映射置信度 |
|-------------|----------|---------------|----------|------------|

置信度取值：`High / Medium / Low`，并在表后附“判定标准”简述（例如：依赖与职责高度一致为 High）。

### 4.4 批次迁移文档格式（每批一个文件）
文件头必须使用 YAML Front Matter，便于机器解析：
```yaml
---
doc_type: migration_batch
batch_id: "<YYYY-MM-DD-short_name>"
date: "<YYYY-MM-DD>"
owner: "<name or team>"
base_commit: "<git_sha>"
status: planned|in_progress|done|rolled_back
scope:
  bounded_contexts: ["<ContextA>", "<ContextB>"]
  layers: ["Domain", "Application", "Interface", "Infrastructure"]
---
```

正文必须包含以下小节（标题可按需要扩展，但不得缺失）：
1. 目标与非目标（Goals / Non-goals）
2. 依赖分析摘要（含：是否存在潜在循环、迁移顺序说明、依赖图引用路径）
3. 变更清单（必须为表格）：
   - `old_path` / `new_path` / `target_context` / `target_layer` / `reason` / `confidence`
4. 验证结果：
   - 编译/启动（命令 + 结果）
   - 测试（命令 + 结果）
   - 架构约束（工具/规则 + 结果）
   - 性能基线（如适用：指标 + 结果）
5. 决策记录（Decisions）与遗留问题（Open Issues）
6. 回退方案（Rollback）：回退命令/策略与注意事项
7. 下一批计划（Next）：候选文件/风险点/所需前置

---

迁移的目标不是完美，而是为后续 AI 重构建立正确的结构基础；保持每个步骤的可验证性比追求一次性完美更重要。
